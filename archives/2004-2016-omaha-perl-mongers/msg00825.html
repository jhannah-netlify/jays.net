<!-- MHonArc v2.6.24 -->
<!--X-Subject: [Omaha.pm] [Fwd: Re: Gedcom.pm &#45; searching for a path from person A to person X?] -->
<!--X-From-R13: Xnl Vnaanu &#60;wnlNwnlf.arg> -->
<!--X-Date: 5 Feb 2006 18:12:08 &#45;0000 -->
<!--X-Message-Id: 43E63FD4.8000505@jays.net -->
<!--X-Content-Type: text/plain -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>[Omaha.pm] [Fwd: Re: Gedcom.pm - searching for a path from person A to person X?]</title>
<link rev="made" href="mailto:jay@jays.net">
</head>
<body>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<hr>
[<a href="msg00824.html">Date Prev</a>][<a href="msg00826.html">Date Next</a>][<a href="msg00824.html">Thread Prev</a>][<a href="msg00828.html">Thread Next</a>][<a href="maillist.html#00825">Date Index</a>][<a href="threads.html#00825">Thread Index</a>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>[Omaha.pm] [Fwd: Re: Gedcom.pm - searching for a path from person A to person X?]</h1>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: &quot;Perl Mongers of Omaha, Nebraska USA&quot; &lt;<a href="mailto:omaha-pm%40pm.org">omaha-pm@pm.org</a>&gt;</li>
<li><em>Subject</em>: [Omaha.pm] [Fwd: Re: Gedcom.pm - searching for a path from person A to person X?]</li>
<li><em>From</em>: Jay Hannah &lt;<a href="mailto:jay%40jays.net">jay@jays.net</a>&gt;</li>
<li><em>Date</em>: Sun, 05 Feb 2006 12:11:32 -0600</li>
<li><em>Delivered-to</em>: <a href="mailto:mailman-omaha-pm%40mailman.pm.dev">mailman-omaha-pm@mailman.pm.dev</a></li>
<li><em>Delivered-to</em>: <a href="mailto:omaha-pm%40pm.org">omaha-pm@pm.org</a></li>
<li><em>List-archive</em>: &lt;<a href="http://mail.pm.org/pipermail/omaha-pm">http://mail.pm.org/pipermail/omaha-pm</a>&gt;</li>
<li><em>List-help</em>: &lt;<a href="mailto:omaha-pm-request@pm.org?subject=help">mailto:omaha-pm-request@pm.org?subject=help</a>&gt;</li>
<li><em>List-id</em>: &quot;Perl Mongers of Omaha, Nebraska USA&quot; &lt;omaha-pm.pm.org&gt;</li>
<li><em>List-post</em>: &lt;<a href="mailto:omaha-pm@pm.org">mailto:omaha-pm@pm.org</a>&gt;</li>
<li><em>List-subscribe</em>: &lt;<a href="http://mail.pm.org/mailman/listinfo/omaha-pm">http://mail.pm.org/mailman/listinfo/omaha-pm</a>&gt;,	&lt;<a href="mailto:omaha-pm-request@pm.org?subject=subscribe">mailto:omaha-pm-request@pm.org?subject=subscribe</a>&gt;</li>
<li><em>List-unsubscribe</em>: &lt;<a href="http://mail.pm.org/mailman/listinfo/omaha-pm">http://mail.pm.org/mailman/listinfo/omaha-pm</a>&gt;,	&lt;<a href="mailto:omaha-pm-request@pm.org?subject=unsubscribe">mailto:omaha-pm-request@pm.org?subject=unsubscribe</a>&gt;</li>
<li><em>Reply-to</em>: &quot;Perl Mongers of Omaha, Nebraska USA&quot; &lt;<a href="mailto:omaha-pm%40pm.org">omaha-pm@pm.org</a>&gt;</li>
<li><em>User-agent</em>: Mozilla Thunderbird 1.0.7 (Macintosh/20050923)</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre style="margin: 0em;">

Paul's reply...

j


-------- Original Message --------
Subject: Re: Gedcom.pm - searching for a path from person A to person X?
Date: Mon, 23 Jan 2006 17:43:19 +0100
From: Paul Johnson &lt;paul@pjcj.net&gt;
To: Jay Hannah &lt;jay@jays.net&gt;
CC: Omaha Perl Mongers &lt;omaha-pm@pm.org&gt;
References: &lt;<a href="msg00686.html">e4f68fcdb67f7986800bd8dddb266d79@jays.net</a>&gt;

On Sat, Nov 26, 2005 at 12:52:27PM -0600, Jay Hannah wrote:

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
Hi Paul --
</pre></blockquote><pre style="margin: 0em;">

Hello Jay (and omaha.pm),

First, my apologies for a delayed reply.

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><pre style="margin: 0em;">
I've got a little over 4000 people in my GEDCOM

   <a  rel="nofollow" href="http://jays.net/genealogy/">http://jays.net/genealogy/</a>
</pre></blockquote><pre style="margin: 0em;">

That's pretty impressive.  I wish I had that much information, but I
spend too much time hacking  Gedcom.pm and too little time actually
researching.

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><tt>I'm also a Perl hacker, and was playing with your Gedcom.pm and 
</tt><tt>wondering if you have any logic to find paths from arbitrary points in 
</tt><tt>GEDCOMs to other arbitrary points.
</tt><pre style="margin: 0em;">

Something like

The path from INDI 0012 to INDI 1077:

Start: INDI 0012
Father: INDI 0078
Mother: INDI 1032
Married: INDI 1999
Daughter: INDI 1066
Married: INDI 0887
Son: INDI 1077

</pre><tt>Once you found the path, of course, you could make it as pretty as you 
</tt><tt>wanted to, Names, dates, etc.
</tt><pre style="margin: 0em;">

Does such a thing exist?
</pre></blockquote><pre style="margin: 0em;">

Im not sure whether anyone has written such a thing directly in Perl,
but I do know of a lifelines script called &quot;relation&quot; that does (mostly)
what you are after.  This script can be translated into Perl using
lines2perl which is a part of the Gedcom.pm release.

I've reproduced the script below.  (It required a small change to
lines2perl.)  You can run this directly, or use it to learn from.  The
original script is after __END__.  The Perl is not wonderful, but I
don't think it's too bad for an automatic translation.

As an aside, lifelines has some really nice reports.  For the most part,
lines2perl will translate them into Perl for you.  (There might be
problems with some of the newer ones if they use new features I haven't
implemented yet.)  See <a  rel="nofollow" href="http://lifelines.sourceforge.net/">http://lifelines.sourceforge.net/</a> and
<a  rel="nofollow" href="ftp://ftp.cac.psu.edu/pub/genealogy/lines/reports/">ftp://ftp.cac.psu.edu/pub/genealogy/lines/reports/</a>

Let me know if you run into any problems.

</pre><blockquote style="border-left: #5555EE solid 0.2em; margin: 0em; padding-left: 0.85em"><tt>                         If not, do you have any thoughts about how I 
</tt><tt>might right it? Any interest in this being a plugin to Gedcom.pm?  
</tt><tt>Gedcom::Search or something?
</tt></blockquote><pre style="margin: 0em;">

If you'd like to write some general method for this I'd be very happy to
include it, either within the distribution or by providing some sort of
plugin support.  If you do this, you might like to subscribe to the
mailing list (details in the README) to keep us informed.

Thanks!




#!/usr/local/bin/perl -w

# This program was generated by lines2perl, which is part of Gedcom.pm.
# Gedcom.pm is Copyright 1999-2005, Paul Johnson (pjcj@cpan.org)
# Version 1.1502 - 20th December 2005

# Gedcom.pm is free.  It is licensed under the same terms as Perl itself.

# The latest version of Gedcom.pm should be available from my homepage:
# <a  rel="nofollow" href="http://www.pjcj.net">http://www.pjcj.net</a>

use strict;

require 5.005;

use diagnostics;
use integer;

use Getopt::Long;

use Gedcom::LifeLines 1.1502;

my $Ged;                                                         # Gedcom object
my %Opts;                                                              # options
my $_Traverse_sub;                                     # subroutine for traverse

sub out  { print  STDERR @_ unless $Opts{quiet} }
sub outf { printf STDERR @_ unless $Opts{quiet} }

sub initialise ()
{
 die &quot;usage: $0 -gedcom_file file.ged\n&quot;
   unless GetOptions(\%Opts,
                     &quot;gedcom_file=s&quot;,
                     &quot;quiet!&quot;,
                     &quot;validate!&quot;,
                    ) and defined $Opts{gedcom_file};
 local $SIG{__WARN__} = sub { out &quot;\n@_&quot; };
 out &quot;reading...&quot;;
 $Ged = Gedcom-&gt;new
 (
   gedcom_file  =&gt; $Opts{gedcom_file},
   callback     =&gt; sub { out &quot;.&quot; }
 );
 if ($Opts{validate})
 {
   out &quot;\nvalidating...&quot;;
   my %x;
   my $vcb = sub
   {
    my ($r) = @_;
    my $t = $r-&gt;{xref};
    out &quot;.&quot; if $t &amp;&amp; !$x{$t}++;
   };
   $Ged-&gt;validate($vcb);
 }
 out &quot;\n&quot;;
 set_ged($Ged);
}

$SIG{__WARN__} = sub
{
 out $_[0] unless $_[0] =~ /^Use of uninitialized value/
};

# /*
# relation - a LifeLines relation computing program
#         by Jim Eggert (eggertj@atc.ll.mit.edu)
#         Version 1,  21 November 1992
#         Version 2,  23 November 1992 (completely revamped)
#         Version 3,  (changed format slightly, modified code somewhat)
#         Version 4,   6 July 1993 (added English language)
#         Version 5,   6 September 1993 (generified language)
</pre><tt># 
</tt><tt># This program calculates the relationship between individuals in a
</tt><pre style="margin: 0em;">
# database.  It does so in three modes.  Mode 1 just does one pair of
# individuals and then exits.  Mode 2 does any number of pairs with a
# common &quot;from&quot; person.  Mode 3 does all pairs with a common &quot;from&quot;
# person.  In general, mode 1 is fastest for simple relationships, but
# if you want one complicated relationship, you may as well do them all.
</pre><tt># 
</tt><tt># Each computed relation is composed of the minimal combination of
</tt><pre style="margin: 0em;">
# parent (fm), sibling (bsS), child (zdC), and spouse (hw) giving the
# relational path from the &quot;from&quot; person to the &quot;to&quot; person.  Each
# incremental relationship (or hop) is coded as follows, with the
# capital letters denoting a person of unknown gender:
#         father  f
#         mother  m
#         parent  P (not used)
#         brother b
#         sister  s
#         sibling S
#         son     z (sorry)
#         daughtr d
#         child   C
#         husband h
#         wife    w
#         spouse  O (sorry again, but usually not possible)
</pre><tt># 
</tt><tt># The report gives the steps required to go from the first person to
</tt><pre style="margin: 0em;">
# the second person.  Thus the printout
#         I93 John JONES fmshwz I95 Fred SMITH
# means that John Jones' father's mother's sister's husband's wife's son
# is Fred Smith.  Notice in this case, the sister's husband's wife is
# not the same as the sister, and the husband's wife's son is not the
# same as the husband's son.  Thus in more understandable English, John
# Jones' paternal grandmother's sister's husband's wife's son from
# another marriage is Fred Smith.
</pre><tt># 
</tt><tt># The program will do a trivial parsing of the path string.  You can
</tt><pre style="margin: 0em;">
# change the language_table to have it print in different languages, as
# long as the word order is unchanged.
</pre><tt># 
</tt><tt># If there is no relation, the program says so.  That at least should be
</tt><pre style="margin: 0em;">
# easy to explain.  Mode 3 only prints out those individuals who are
# related to the &quot;from&quot; individual.
# */
my $plist;
my $hlist;
my $mark;
my $keys;
my $found;
my $do_names;
my $language;
my $language_table;
my $token;
my $untoken;
sub include ($$$$$)
{
 my($person, $hops, $keypath, $path, $pathend) = @_;
 my $and;
 my $entry;
 my $eq;
 my $pkey;
 if (($person &amp;&amp; ($found == 0)))
 {
   $pkey = &amp;key($person);
   if ($entry = $mark-&gt;{$pkey})
   {
     if ((&amp;strcmp($entry, &quot;is not related to&quot;) == 0))
     {
       $found = 1;
       $plist = [];
       $hlist = [];
       $mark-&gt;{&amp;save($pkey)} = &amp;save(&amp;concat($path, $pathend));
       $keys-&gt;{&amp;save($pkey)} = &amp;save(&amp;concat(&amp;concat($keypath, &quot;@&quot;), $pkey));
     }
   }
   else
   {
     push @$plist, &amp;save($pkey);
     push @$hlist, $hops;
     $mark-&gt;{&amp;save($pkey)} = &amp;save(&amp;concat($path, $pathend));
     $keys-&gt;{&amp;save($pkey)} = &amp;save(&amp;concat(&amp;concat($keypath, &quot;@&quot;), $pkey));
   }
 }
 undef
}

sub get_token ($)
{
 my($input) = @_;
 my $eq;
 my $first_delim;
 my $not;
 # /*  Parse a token from the input string.
 #     Tokens are separated by one or more &quot;@&quot;s.
 #     Set global parameter token to the first token string.
 #     Set global parameter untoken to the rest of the string after first token.
 # */
 # /* strip leading @s */
</pre><tt> #     
</tt><tt> $untoken = &amp;save($input);
</tt><pre style="margin: 0em;">
 $first_delim = &amp;index($untoken, &quot;@&quot;, 1);
 LOOP: while (($first_delim == 1))
 {
   $untoken = &amp;save(&amp;substring($untoken, 2, &amp;strlen($untoken)));
   $first_delim = &amp;index($untoken, &quot;@&quot;, 1);
 }
 # /* get token and untoken */
</pre><tt> #     
</tt><tt> if ((! $first_delim))
</tt><pre style="margin: 0em;">
 {
   $token = &amp;save($untoken);
   $untoken = &amp;save(&quot;&quot;);
 }
 else
 {
   $token = &amp;save(&amp;substring($untoken, 1, ($first_delim - 1)));
   $untoken = &amp;save(&amp;substring($untoken, ($first_delim + 1), &amp;strlen($untoken)));
 }
 undef
}

sub parse_relation ($$)
{
 my($relation, $keypath) = @_;
 my $charcounter;
 my $le;
 my $not;
 my $strlen;
 if ((! $language))
 {
   display &quot; &quot;;
   display $relation;
   if ($do_names)
   {
     $untoken = $keypath;
     display &amp;get_token($untoken);
     LOOP: while (&amp;strlen($untoken))
     {
       display &amp;get_token($untoken);
       display &quot; &quot;;
       display $token;
       display &quot; &quot;;
       display &amp;name(&amp;indi($token));
     }
   }
   display &quot; &quot;;
 }
 else
 {
   $charcounter = 1;
   $untoken = $keypath;
   display &amp;get_token($untoken);
   LOOP: while (($charcounter &lt;= &amp;strlen($relation)))
   {
     display $language_table-&gt;{&amp;substring($relation, $charcounter, $charcounter)};
     if ($do_names)
     {
       display &amp;get_token($untoken);
       display &quot; &quot;;
       display $token;
       display &quot; &quot;;
       display &amp;name(&amp;indi($token));
     }
     $charcounter = ($charcounter + 1);
   }
   display &quot; is &quot;;
 }
 undef
}

sub main ()
{
 my $child;
 my $cnum;
 my $eq;
 my $fam;
 my $female;
 my $from_key;
 my $from_person;
 my $hopcount;
 my $keypath;
 my $male;
 my $mode;
 my $ne;
 my $num;
 my $path;
 my $pathend;
 my $person;
 my $pkey;
 my $pnum;
 my $prev_hopcount;
 my $spouse;
 my $strcmp;
 my $to_key;
 my $to_person;
 my $want_another;
 $mark = {};
 $keys = {};
 $plist = [];
 $hlist = [];
 $language_table = {};
 $language_table-&gt;{&quot;f&quot;} = &quot;'s father&quot;;
 $language_table-&gt;{&quot;m&quot;} = &quot;'s mother&quot;;
 $language_table-&gt;{&quot;P&quot;} = &quot;'s parent&quot;;
 $language_table-&gt;{&quot;b&quot;} = &quot;'s brother&quot;;
 $language_table-&gt;{&quot;s&quot;} = &quot;'s sister&quot;;
 $language_table-&gt;{&quot;S&quot;} = &quot;'s sibling&quot;;
 $language_table-&gt;{&quot;z&quot;} = &quot;'s son&quot;;
 $language_table-&gt;{&quot;d&quot;} = &quot;'s daughter&quot;;
 $language_table-&gt;{&quot;C&quot;} = &quot;'s child&quot;;
 $language_table-&gt;{&quot;h&quot;} = &quot;'s husband&quot;;
 $language_table-&gt;{&quot;w&quot;} = &quot;'s wife&quot;;
 $language_table-&gt;{&quot;O&quot;} = &quot;'s spouse&quot;;
 display &amp;getindimsg($from_person, &quot;Enter person to compute relation from:&quot;);
 $from_key = &amp;save(&amp;key($from_person));
 $hopcount = 0;
 $prev_hopcount = (- 1);
 $found = 0;
 display &amp;include($from_person, $hopcount, &quot;&quot;, &quot;&quot;, &quot;&quot;);
 display &amp;getintmsg($mode, &quot;Enter 1 for a single relation, 2 for several, 3 for all:&quot;);
 display &amp;getintmsg($language, &quot;Enter 0 for brief, 1 for English-language relationships:&quot;);
 display &amp;getintmsg($do_names, &quot;Enter 0 to omit, 1 to output names of all intervening relatives:&quot;);
 if (($mode == 1))
 {
   display &amp;getindimsg($to_person, &quot;Enter one person to compute relation to:&quot;);
   $to_key = &amp;save(&amp;key($to_person));
   if (&amp;strcmp($from_key, $to_key))
   {
     $mark-&gt;{$to_key} = &quot;is not related to&quot;;
   }
   else
   {
     $plist = [];
     $hlist = [];
   }
 }
 LOOP: while ($pkey = (shift @$plist))
 {
   $person = &amp;indi($pkey);
   $hopcount = (shift @$hlist);
   $path = $mark-&gt;{$pkey};
   $keypath = $keys-&gt;{$pkey};
   if (($hopcount != $prev_hopcount))
   {
     display &amp;print(&quot;.&quot;);
     $prev_hopcount = $hopcount;
   }
   $hopcount = ($hopcount + 1);
   display &amp;include(&amp;father($person), $hopcount, $keypath, $path, &quot;f&quot;);
   display &amp;include(&amp;mother($person), $hopcount, $keypath, $path, &quot;m&quot;);
   $cnum = 0;
   LOOP: for $child ( do { my $e = &amp;parents($person); $e ? $e-&gt;children : ()} )
   {
     $cnum++;
       if (&amp;male($child))
       {
         $pathend = &quot;b&quot;;
       }
       elsif (&amp;female($child))
       {
         $pathend = &quot;s&quot;;
       }
       else
       {
         $pathend = &quot;S&quot;;
       }
       display &amp;include($child, $hopcount, $keypath, $path, $pathend);
   }
   $pnum = 0;
   LOOP: for $fam ($person-&gt;fams)
   {
     for $spouse ($fam-&gt;parents || undef)
     {
       next if $spouse &amp;&amp; $spouse-&gt;xref eq $person-&gt;xref;
       $pnum++;
       if (&amp;male($spouse))
       {
         $pathend = &quot;h&quot;;
       }
       elsif (&amp;female($spouse))
       {
         $pathend = &quot;w&quot;;
       }
       else
       {
         $pathend = &quot;O&quot;;
       }
       display &amp;include($spouse, $hopcount, $keypath, $path, $pathend);
       $cnum = 0;
       LOOP: for $child ( do { my $e = $fam; $e ? $e-&gt;children : ()} )
       {
         $cnum++;
           if (&amp;male($child))
           {
             $pathend = &quot;z&quot;;
           }
           elsif (&amp;female($child))
           {
             $pathend = &quot;d&quot;;
           }
           else
           {
             $pathend = &quot;C&quot;;
           }
           display &amp;include($child, $hopcount, $keypath, $path, $pathend);
       }
     }
   }
 }
 if (($mode == 1))
 {
   display $from_key;
   display &quot; &quot;;
   display &amp;name(&amp;indi($from_key));
   display &amp;parse_relation(&amp;save($mark-&gt;{$to_key}), $keys-&gt;{$to_key});
   display $to_key;
   display &quot; &quot;;
   display &amp;name(&amp;indi($to_key));
   display &quot;\n&quot;;
 }
 if (($mode == 2))
 {
   $want_another = 1;
   LOOP: while ($want_another)
   {
     display &amp;getindimsg($to_person, &quot;Enter person to compute relation to:&quot;);
     $to_key = &amp;save(&amp;key($to_person));
     display $from_key;
     display &quot; &quot;;
     display &amp;name(&amp;indi($from_key));
     if ($path = $mark-&gt;{$to_key})
     {
       display &amp;parse_relation(&amp;save($path), $keys-&gt;{$to_key});
     }
     else
     {
       display &quot; is not related to &quot;;
     }
     display $to_key;
     display &quot; &quot;;
     display &amp;name($to_person);
     display &quot;\n&quot;;
     display &amp;getintmsg($want_another, &quot;Enter 0 if done, 1 if you want another to person:&quot;);
   }
 }
 if (($mode == 3))
 {
   display $from_key;
   display &quot; &quot;;
   display &amp;name(&amp;indi($from_key));
   display &quot; ---&gt;\n&quot;;
   $num = 0;
   LOOP: for $to_person ($Ged-&gt;individuals)
   {
     $num++;
     $to_key = &amp;save(&amp;key($to_person));
     if ($path = $mark-&gt;{$to_key})
     {
       display &amp;parse_relation(&amp;save($path), $keys-&gt;{$to_key});
       display $to_key;
       display &quot; &quot;;
       display &amp;name($to_person);
       display &quot;\n&quot;;
     }
   }
 }
 undef
}


initialise();
main();
flush();
0

__END__

Original LifeLines program follows:

/*
relation - a LifeLines relation computing program
       by Jim Eggert (eggertj@atc.ll.mit.edu)
       Version 1,  21 November 1992
       Version 2,  23 November 1992 (completely revamped)
       Version 3,  (changed format slightly, modified code somewhat)
       Version 4,   6 July 1993 (added English language)
       Version 5,   6 September 1993 (generified language)

This program calculates the relationship between individuals in a
database.  It does so in three modes.  Mode 1 just does one pair of
individuals and then exits.  Mode 2 does any number of pairs with a
common &quot;from&quot; person.  Mode 3 does all pairs with a common &quot;from&quot;
person.  In general, mode 1 is fastest for simple relationships, but
if you want one complicated relationship, you may as well do them all.

Each computed relation is composed of the minimal combination of
parent (fm), sibling (bsS), child (zdC), and spouse (hw) giving the
relational path from the &quot;from&quot; person to the &quot;to&quot; person.  Each
incremental relationship (or hop) is coded as follows, with the
capital letters denoting a person of unknown gender:
       father  f
       mother  m
       parent  P (not used)
       brother b
       sister  s
       sibling S
       son     z (sorry)
       daughtr d
       child   C
       husband h
       wife    w
       spouse  O (sorry again, but usually not possible)

The report gives the steps required to go from the first person to
the second person.  Thus the printout
       I93 John JONES fmshwz I95 Fred SMITH
means that John Jones' father's mother's sister's husband's wife's son
is Fred Smith.  Notice in this case, the sister's husband's wife is
not the same as the sister, and the husband's wife's son is not the
same as the husband's son.  Thus in more understandable English, John
Jones' paternal grandmother's sister's husband's wife's son from
another marriage is Fred Smith.

The program will do a trivial parsing of the path string.  You can
change the language_table to have it print in different languages, as
long as the word order is unchanged.

If there is no relation, the program says so.  That at least should be
easy to explain.  Mode 3 only prints out those individuals who are
related to the &quot;from&quot; individual.
*/

global(plist)
global(hlist)
global(mark)
global(keys)
global(found)
global(do_names)
global(language)
global(language_table)
global(token)
global(untoken)

proc include(person,hops,keypath,path,pathend)
{
   if (and(person,eq(found,0))) {
       set(pkey,key(person))
       if (entry,lookup(mark,pkey)) {
           if (eq(strcmp(entry,&quot;is not related to&quot;),0)) {
               set(found,1)
               list(plist)
               list(hlist)
               insert(mark,save(pkey),save(concat(path,pathend)))
               insert(keys,save(pkey),save(concat(concat(keypath,&quot;@&quot;),pkey)))
           }
       }
       else {
           enqueue(plist,save(pkey))
           enqueue(hlist,hops)
           insert(mark,save(pkey),save(concat(path,pathend)))
           insert(keys,save(pkey),save(concat(concat(keypath,&quot;@&quot;),pkey)))
       }
   }
}

proc get_token(input) {
/*  Parse a token from the input string.
   Tokens are separated by one or more &quot;@&quot;s.
   Set global parameter token to the first token string.
   Set global parameter untoken to the rest of the string after first token.
*/
/* strip leading @s */
   set(untoken,save(input))
   set(first_delim,index(untoken,&quot;@&quot;,1))
   while (eq(first_delim,1)) {
       set(untoken,save(substring(untoken,2,strlen(untoken))))
       set(first_delim,index(untoken,&quot;@&quot;,1))
   }
/* get token and untoken */
   if (not(first_delim)) {
       set(token,save(untoken))
       set(untoken,save(&quot;&quot;))
   }
   else {
       set(token,save(substring(untoken,1,sub(first_delim,1))))
       set(untoken,save(
           substring(untoken,add(first_delim,1),strlen(untoken))))
   }
}

proc parse_relation(relation,keypath) {
   if (not(language)) {
       &quot; &quot; relation
       if (do_names) {
           set(untoken,keypath)
           call get_token(untoken)
           while(strlen(untoken)) {
               call get_token(untoken)
               &quot; &quot; token &quot; &quot; name(indi(token))
           }
       }
       &quot; &quot;
   }
   else {
       set(charcounter,1)
       set(untoken,keypath)
       call get_token(untoken)
       while (le(charcounter,strlen(relation))) {
           lookup(language_table,substring(relation,charcounter,charcounter))
           if (do_names) {
               call get_token(untoken)
               &quot; &quot; token &quot; &quot; name(indi(token))
           }
           set(charcounter,add(charcounter,1))
       }
       &quot; is &quot;
   }
}

proc main ()
{
   table(mark)
   table(keys)
   list(plist)
   list(hlist)

   table(language_table)
   insert(language_table,&quot;f&quot;,&quot;'s father&quot;)
   insert(language_table,&quot;m&quot;,&quot;'s mother&quot;)
   insert(language_table,&quot;P&quot;,&quot;'s parent&quot;)
   insert(language_table,&quot;b&quot;,&quot;'s brother&quot;)
   insert(language_table,&quot;s&quot;,&quot;'s sister&quot;)
   insert(language_table,&quot;S&quot;,&quot;'s sibling&quot;)
   insert(language_table,&quot;z&quot;,&quot;'s son&quot;)
   insert(language_table,&quot;d&quot;,&quot;'s daughter&quot;)
   insert(language_table,&quot;C&quot;,&quot;'s child&quot;)
   insert(language_table,&quot;h&quot;,&quot;'s husband&quot;)
   insert(language_table,&quot;w&quot;,&quot;'s wife&quot;)
   insert(language_table,&quot;O&quot;,&quot;'s spouse&quot;)

   getindimsg(from_person,
       &quot;Enter person to compute relation from:&quot;)
   set(from_key,save(key(from_person)))
   set(hopcount,0)
   set(prev_hopcount,neg(1))
   set(found,0)
   call include(from_person,hopcount,&quot;&quot;,&quot;&quot;,&quot;&quot;)
   getintmsg(mode,&quot;Enter 1 for a single relation, 2 for several, 3 for all:&quot;)
   getintmsg(language,
       &quot;Enter 0 for brief, 1 for English-language relationships:&quot;)
   getintmsg(do_names,
       &quot;Enter 0 to omit, 1 to output names of all intervening relatives:&quot;)
   if (eq(mode,1)) {
       getindimsg(to_person,
           &quot;Enter one person to compute relation to:&quot;)
       set(to_key,save(key(to_person)))
       if (strcmp(from_key,to_key)) {
           insert(mark,to_key,&quot;is not related to&quot;)
       }
       else {
           list(plist)
           list(hlist)
       }
   }
   while (pkey,dequeue(plist)) {
       set(person,indi(pkey))
       set(hopcount,dequeue(hlist))
       set(path,lookup(mark,pkey))
       set(keypath,lookup(keys,pkey))
       if (ne(hopcount,prev_hopcount)) {
           print(&quot;.&quot;)
           set(prev_hopcount,hopcount)
       }
       set(hopcount,add(hopcount,1))
       call include(father(person),hopcount,keypath,path,&quot;f&quot;)
       call include(mother(person),hopcount,keypath,path,&quot;m&quot;)
       children(parents(person),child,cnum) {
           if (male(child)) { set(pathend,&quot;b&quot;) }
           elsif (female(child)) { set(pathend,&quot;s&quot;) }
           else { set(pathend,&quot;S&quot;) }
           call include(child,hopcount,keypath,path,pathend)
       }
       families(person,fam,spouse,pnum) {
           if (male(spouse)) { set(pathend,&quot;h&quot;) }
           elsif (female(spouse)) { set(pathend,&quot;w&quot;) }
           else { set(pathend,&quot;O&quot;) }
           call include(spouse,hopcount,keypath,path,pathend)
           children(fam,child,cnum) {
               if (male(child)) { set(pathend,&quot;z&quot;) }
               elsif (female(child)) { set(pathend,&quot;d&quot;) }
               else { set(pathend,&quot;C&quot;) }
               call include(child,hopcount,keypath,path,pathend)
           }
       }
   }
   if (eq(mode,1)) {
       from_key &quot; &quot; name(indi(from_key))
       call parse_relation(save(lookup(mark,to_key)),lookup(keys,to_key))
       to_key   &quot; &quot; name(indi(to_key)) &quot;\n&quot;
   }
   if (eq(mode,2)) {
       set(want_another,1)
       while (want_another) {
           getindimsg(to_person,&quot;Enter person to compute relation to:&quot;)
           set(to_key,save(key(to_person)))
           from_key &quot; &quot; name(indi(from_key))
           if (path,lookup(mark,to_key)) {
               call parse_relation(save(path),lookup(keys,to_key))
           }
           else { &quot; is not related to &quot; }
           to_key  &quot; &quot;  name(to_person) &quot;\n&quot;
           getintmsg(want_another,
                 &quot;Enter 0 if done, 1 if you want another to person:&quot;)
       }
   }
   if (eq(mode,3)) {
       from_key &quot; &quot; name(indi(from_key)) &quot; ---&gt;\n&quot;
       forindi(to_person,num) {
           set(to_key,save(key(to_person)))
           if (path,lookup(mark,to_key)) {
               call parse_relation(save(path),lookup(keys,to_key))
               to_key &quot; &quot; name(to_person) &quot;\n&quot;
           }
       }
   }
}

--
Paul Johnson - paul@pjcj.net
<a  rel="nofollow" href="http://www.pjcj.net">http://www.pjcj.net</a>

</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<!--X-Follow-Ups-End-->
<!--X-References-->
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg00824.html">Re: [Omaha.pm] [pm_groups] Perl Mongers map via Google Maps API</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg00826.html">Re: [Omaha.pm] Gedcom.pm - searching for a path from person A to	person X?</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg00824.html">Re: [Omaha.pm] [pm_groups] Perl Mongers map via Google Maps API</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00828.html">[Omaha.pm] One-liner adding machine</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#00825"><strong>Date</strong></a></li>
<li><a href="threads.html#00825"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</body>
</html>
